<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Zack&#39;s Notablog</title><link>/tags/golang/</link><description>Recent content in Golang on Zack&#39;s Notablog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 May 2018 07:00:57 -0700</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Shallow `go get`</title><link>/shallow-go-get/</link><pubDate>Sun, 06 May 2018 07:00:57 -0700</pubDate><guid>/shallow-go-get/</guid><description>This is a little hack to use shallow clones for new git checkouts with go get. Unfortunately for Gophers, this has been an open issue for three years counting without a workable solution aside from patching the go toolchain yourself. This solution utilizes a git wrapper that determines if a pull/clone is happening and then makes sure it is shallow.
The wrapper is only a few lines of code, here&amp;rsquo;s the main.</description></item><item><title>FIND3</title><link>/find3/</link><pubDate>Sat, 17 Mar 2018 09:41:01 -0600</pubDate><guid>/find3/</guid><description>There is a new version of FIND now, called &amp;ldquo;FIND3.&amp;rdquo; Its public on Github now.
FIND is the Framework for Internal Navigation and Discovery. It is basically an indoor GPS for your house or business, using only a simple smartphone or laptop.
This is an idea I started thinking about 8 years ago and wrote the first code in PHP almost four years ago, dubbed version 0, as a proof-of-concept.</description></item><item><title>How to easily make nested templates (Go)</title><link>/golang-nested-templates/</link><pubDate>Fri, 10 Nov 2017 04:50:00 -0700</pubDate><guid>/golang-nested-templates/</guid><description>https://play.golang.org/p/OVkruYsBVV
package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;text/template&amp;#34; ) type View struct { Title string Content string } func main() { header := ` {{define &amp;#34;header&amp;#34;}}&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;{{ $.Title }}&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; {{end}}` page := ` This line should not show {{define &amp;#34;indexPage&amp;#34;}}&amp;lt;html&amp;gt; {{template &amp;#34;header&amp;#34; .}}&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;{{ .Content }}&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; {{end}}` view := View{Title: &amp;#34;some title&amp;#34;, Content: &amp;#34;some content&amp;#34;} // Here we try to set which page to view as content t := template.</description></item><item><title>Using crawdad</title><link>/crawdad/</link><pubDate>Wed, 11 Oct 2017 20:03:10 -0600</pubDate><guid>/crawdad/</guid><description>crawdad is a simple, yet powerful alternative for scraping in a distributed, persistent manner (backed by Redis). It can do simple things, like generating site maps. It can also do complicated things, like extracting all the quotes from every page on a quotes website (tutorial follows).
Install First get Docker which will be used for running Redis.
Then you can simply download crawdad:
$ wget https://github.com/schollz/crawdad/releases/download/v3.0.0/crawdad_3.0.0_linux_amd64.zip $ unzip crawdad*zip $ sudo mv crawdad*amd64 /usr/local/bin/crawdad Unlike many other scraping frameworks, crawdad is a single binary that has no dependencies.</description></item><item><title>Why Go?</title><link>/why-go/</link><pubDate>Sat, 29 Apr 2017 09:48:59 -0600</pubDate><guid>/why-go/</guid><description>Lots of people ask me this question, and I end up writing the same answer over and over. I just wrote my plain answer here so I can just link to it. Don&amp;rsquo;t hesitate to ask me other questions, though if you need. The basic answer is: because of time and money.
Coding in Go saves me time. When I write code, I often write run the program periodically to test it.</description></item></channel></rss>